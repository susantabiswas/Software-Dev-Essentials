/*
    https://leetcode.com/problems/minimize-malware-spread-ii/
    
    The core idea is to find the components which are connected to only one 1 malware. As this
    would mean that if we remove that malware node then all those nodes can be saved. 
    We can do this via following solutions:
    
    1. Articulation Point
    Find if the malwares are articulation points, for each of the articulation points (malware infected), find
    the subtree size which has no other malware and save this result for each of the malwares.
    Finally pick the one with which can save the max no. of nodes.
    
    2. Union Find:
    Create the graph without the malware nodes. Then for each of the malwares, find the components that connects to it.
    Also for the components, track the no. of malwares they connect to it. Finally for each of the malwares, pick the connecting
    component which has doesnt connect to any other malware and this is the potential no. of nodes that can be saved
    by removing this malware node. Do the same for other nodes as well and pick the best one.
*/
class Solution {
private:
    class UnionFind {
        public: 
            vector<int> root, size;
            UnionFind(int n) {
                root.resize(n);
                for(int i = 0; i < n; i++)
                    root[i] = i;

                size.resize(n, 1);
            }

            int getRoot(int u) {
                while(u != root[u]) {
                    root[u] = root[root[u]];
                    u = root[u];
                }
                return u;
            }

            bool Find(int a, int b) {
                return getRoot(a) == getRoot(b);
            }

            void Union(int a, int b) {
                int root_a = getRoot(a);
                int root_b = getRoot(b);
                
                if(root_a == root_b)
                    return;
                
                // The smaller component becomes part of bigger
                if(size[root_a] > size[root_b] ) {
                    size[root_a] += size[root_b];
                    root[root_b] = root_a;
                }
                else {
                    size[root_b] += size[root_a];
                    root[root_a] = root_b;
                }
            }
    };

public:

    int findArticulationPoint(int curr, int& timer, vector<vector<int>>& graph, vector<bool>& visited,
                    vector<int>& discovery_time, vector<int>& earliest_back_edge,
                    map<int, int>& infection_sources, int parent = -1) {
        // mark it visited
        visited[curr] = true;
        // set the discovery time and initial ealiest known back edge
        discovery_time[curr] = earliest_back_edge[curr] = timer++;

        // whether the subtree with curr as root has malware or not
        bool infected_cluster = infection_sources.count(curr);

        // Total no. of uninfected nodes in the subtrees with root as curr node
        int num_uninfected_subtree = infection_sources.count(curr) == 0;
        // explore the neighbors
        for(int neighbor = 0; neighbor < graph[curr].size(); neighbor++) {
            // If the node is not connected to current node 
            if(!graph[curr][neighbor])
                continue;

            // neighbor not visited
            if(!visited[neighbor]) {
                int num_uninfected = findArticulationPoint(neighbor, timer, graph, visited, discovery_time,
                                    earliest_back_edge, infection_sources, curr);

                // If the subtree returns 0, means there is a malware there and hence even if we remove current
                // node, the subtree will still get infected
                infected_cluster = infected_cluster || (num_uninfected == 0);
                num_uninfected_subtree += num_uninfected;
            
                earliest_back_edge[curr] = min(earliest_back_edge[curr], earliest_back_edge[neighbor]);
                // check if it is an articulation point and also part of the initial infection source
                if(earliest_back_edge[neighbor] >= discovery_time[curr])
                    infection_sources[curr] += num_uninfected;
            }
            // Neighbor is an earlier node but not the parent of current node
            else if(parent != neighbor)
                earliest_back_edge[curr] = min(earliest_back_edge[curr], discovery_time[neighbor]);
        }
        
        // If current node is infected, it's entire subtree will get the malware
        return infected_cluster ? 0 : num_uninfected_subtree;
    }

    // Solution 1: Tarjan's Algo
    // TC: O(N^2), due to adjacency matrix representation
    // SC: O(N)
    int tarjanSol(vector<vector<int>>& graph, vector<int>& initial) {
        int N = graph.size();
        vector<bool> visited(N, false);
        vector<int> discovery_time(N, -1);
        vector<int> earliest_back_edge(N, INT_MAX);
        
        // For O(1) access of initial infection sources
        // <node, no. of uninfected neighbors>
        map<int, int> infection_sources;
        for(auto source: initial)
            infection_sources[source] = 0;

        int timer = 1;

        for(auto node: initial) {
            if(!visited[node])
                findArticulationPoint(node, timer, graph, visited, discovery_time,
                                      earliest_back_edge, infection_sources);
        }

        // Find out which source spread the malware to most number of uninfected nodes
        int ans = INT_MAX, max_spread = -1;
        
        // Pick the Articulation point which can save max number of nodes
        for(auto node: initial) {
            int spread = infection_sources[node];
            if(spread > max_spread || (spread == max_spread && node < ans)) {
                max_spread = spread;
                ans = node;
            }
        }
        
        return ans;
    }
    
    // Sol2 : Union Find
    // TC: O(N^2)
    // SC: O(N)
    int unionFindSol(vector<vector<int>>& graph, vector<int>& initial) {
        int N = graph.size();
        UnionFind uf(N);
        
        // Tracks how many nodes the infected source can infect
        // <node, no. of nodes uninfected connected to it>
        unordered_map<int, int> infection_spread;
        for(auto node: initial)
            infection_spread[node] = 0;
        
        // Create graph without the infected source nodes
        for(int i = 0; i < N; i++) {
            // skip infection source nodes
            if(infection_spread.count(i))
                continue;
            // we start from i+1, since the nodes before before i would have
            // already created a link with the node
            for(int j = i + 1; j < N; j++) {
                // skip infection source nodes
                if(infection_spread.count(j))
                    continue;
                if(graph[i][j])
                uf.Union(i, j);
            }
        }

        // <component, no. of infected sources it is connected to>
        // This will help to know whether a component is connected to more than 1 infected
        // source or not. If a component is connected to more than 1 infected node, then removing
        // just 1 infected node won't change anything and the component will get infected by the other 
        // infected node(s)
        unordered_map<int, int> infection_source_connections;
        // <infected_node, no. of components it is connected to>
        unordered_map<int, unordered_set<int>> connected_components;

        // Now that the graph is created without any infection sources,
        // for each of the infection sources, find how many components it connects
        for(auto node: initial) {
            for(int i = 0; i < N; i++) {
                if(graph[node][i] && !infection_spread.count(i)) {
                    // Find the component the neighboring node is part of
                    int component = uf.getRoot(i);
                    connected_components[node].emplace(component);
                }
            }
            for(auto component: connected_components[node])
                // Increment the count of infected nodes the current component is connected to
                ++infection_source_connections[component];
        }

        int ans = INT_MAX, max_spread = -1;
        // Now for each infected node, check how many uninfected nodes are connected to it
        for(auto node: initial) {
            for(auto component: connected_components[node]) {
                // component is only conneted to current infected node, so the entire
                // nodes in the components can be saved
                if(infection_source_connections[component] == 1) {
                    infection_spread[node] += uf.size[component];
                }
            }
            
            if(infection_spread[node] > max_spread || 
                (infection_spread[node] == max_spread && node < ans)) {
                max_spread = infection_spread[node];
                ans = node;
            } 
        }
    
        return ans;
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // return tarjanSol(graph, initial);
        return unionFindSol(graph, initial);
    }
};
